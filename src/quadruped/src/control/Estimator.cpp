
#include "control/Estimator.h"
#include "common/mathTools.h"
#include "common/enumClass.h"

/**
 * 状态估计器构造函数（完整参数版本）
 * @param robotModel 四足机器人模型指针，用于获取运动学参数
 * @param lowState 底层状态信息指针，包含IMU、关节数据等实时信息
 * @param contact 足端接触状态指针（四维向量），0/1表示各腿是否接触地面
 * @param phase 步态相位指针（四维向量），范围[0,1]表示各腿步态周期进度
 * @param dt 控制周期时间步长（秒），用于离散系统建模
 * @param Qdig 过程噪声协方差矩阵的对角线元素（18维），用于卡尔曼滤波
 * @param testName 估计器名称标识，用于区分不同测试场景的配置
 * 
 * 功能说明：
 * 1. 通过初始化列表完成成员变量初始化
 * 2. 调用系统初始化方法建立状态空间模型
 */
Estimator::Estimator(QuadrupedRobot *robotModel, // 四足机器人模型指针
                    LowlevelState* lowState,     //底层状态信息指针，包含IMU,关节数据等实时信息            
                    VecInt4 *contact,            //足端接触状态指针（四维向量），0/1表示各腿是否接触地面
                    Vec4 *phase,                 //步态相位指针（四维向量），范围[0,1]表示各腿步态周期进度
                    double dt,                   //控制周期时间步长（秒），用于离散系统建模
                    Vec18 Qdig,                  //过程噪声协方差矩阵的对角线元素（18维），用于卡尔曼滤波
                    std::string testName         //估计器名称标识，用于区分不同测试场景的配置
                )
          :_robModel(robotModel), _lowState(lowState), _contact(contact),
           _phase(phase), _dt(dt), _Qdig(Qdig), _estName(testName){

    _initSystem(); // 执行系统模型初始化（状态空间矩阵配置等）
}

Estimator::Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, 
                     VecInt4 *contact, Vec4 *phase, double dt)
          :_robModel(robotModel), _lowState(lowState), _contact(contact), 
           _phase(phase), _dt(dt){

    for(int i(0); i<_Qdig.rows(); ++i){
        if(i < 3){
            _Qdig(i) = 0.0003;
        }
        else if(i < 6){
            _Qdig(i) = 0.0003;
        }
        else{
            _Qdig(i) = 0.01;
        }
    }

    _estName = "current";

    _initSystem();

}

Estimator::~Estimator(){
}

void Estimator::_initSystem(){
    // 初始化基础物理参数
    _g << 0, 0, -9.81;          // 重力加速度向量 (m/s²)
    _largeVariance = 100;       // 初始协方差放大系数

    // 状态向量初始化
    _xhat.setZero();            // 状态估计向量 [位置(3), 速度(3), 足端位置(12)]
    _u.setZero();               // 控制输入向量

    // 状态转移矩阵 A 初始化（18x18）    
    _A.setZero();
    _A.block(0, 0, 3, 3) = I3;        // 位置积分项
    _A.block(0, 3, 3, 3) = I3 * _dt;  // 速度对位置的影响
    _A.block(3, 3, 3, 3) = I3;        // 速度保持项
    _A.block(6, 6, 12, 12) = I12;     // 足端位置保持项
    
    // 控制输入矩阵 B 初始化（18x3）
    _B.setZero();
    _B.block(3, 0, 3, 3) = I3 * _dt;  // 加速度对速度的影响

    // 观测矩阵 C 初始化（28x18）
    _C.setZero();
    // 位置观测部分（前12行对应4个足端的位置观测）
    _C.block(0, 0, 3, 3) = -I3;  // 足端1位置观测
    _C.block(3, 0, 3, 3) = -I3;  // 足端2位置观测
    _C.block(6, 0, 3, 3) = -I3;  // 足端3位置观测 
    _C.block(9, 0, 3, 3) = -I3;  // 足端4位置观测

    // 速度观测部分（中间12行对应4个足端的速度观测）
    _C.block(12, 3, 3, 3) = -I3;  // 足端1速度观测
    _C.block(15, 3, 3, 3) = -I3;  // 足端2速度观测
    _C.block(18, 3, 3, 3) = -I3;  // 足端3速度观测
    _C.block(21, 3, 3, 3) = -I3;  // 足端4速度观测
    _C.block(0, 6, 12, 12) = I12; // 足端位置保持项

    // 足端高度观测（最后4行）
    _C(24, 8) = 1;   // 足端1高度观测
    _C(25, 11) = 1;  // 足端2高度观测
    _C(26, 14) = 1;  // 足端3高度观测
    _C(27, 17) = 1;  // 足端4高度观测


    // 协方差矩阵初始化
    _P.setIdentity();
    _P = _largeVariance * _P;  // 初始状态协方差矩阵

     // 观测噪声协方差矩阵 R（28x28），通过实验数据预定义
    _RInit <<  0.008 , 0.012 ,-0.000 ,-0.009 , 0.012 , 0.000 , 0.009 ,-0.009 ,-0.000 ,-0.009 ,-0.009 , 0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 ,-0.000 ,-0.001 ,-0.002 , 0.000 ,-0.000 ,-0.003 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
               0.012 , 0.019 ,-0.001 ,-0.014 , 0.018 ,-0.000 , 0.014 ,-0.013 ,-0.000 ,-0.014 ,-0.014 , 0.001 ,-0.001 , 0.001 ,-0.001 , 0.000 , 0.000 ,-0.001 ,-0.003 , 0.000 ,-0.001 ,-0.004 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
               -0.000, -0.001,  0.001,  0.001, -0.001,  0.000, -0.000,  0.000, -0.000,  0.001,  0.000, -0.000,  0.000, -0.000,  0.000,  0.000, -0.000, -0.000,  0.000, -0.000, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
               -0.009, -0.014,  0.001,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001,  0.000,  0.000,  0.001, -0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
               0.012 , 0.018 ,-0.001 ,-0.013 , 0.018 ,-0.000 , 0.013 ,-0.013 ,-0.000 ,-0.013 ,-0.013 , 0.001 ,-0.001 , 0.000 ,-0.001 , 0.000 , 0.001 ,-0.001 ,-0.003 , 0.000 ,-0.001 ,-0.004 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
               0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 , 0.001 , 0.000 , 0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000,
               0.009 , 0.014 ,-0.000 ,-0.010 , 0.013 , 0.000 , 0.010 ,-0.010 ,-0.000 ,-0.010 ,-0.010 , 0.000 ,-0.001 , 0.000 ,-0.001 , 0.000 ,-0.000 ,-0.001 ,-0.001 , 0.000 ,-0.000 ,-0.003 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
               -0.009, -0.013,  0.000,  0.010, -0.013,  0.000, -0.010,  0.009,  0.000,  0.010,  0.010, -0.000,  0.001, -0.000,  0.000, -0.000,  0.000,  0.001,  0.002,  0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
               -0.000, -0.000, -0.000,  0.000, -0.000, -0.000, -0.000,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000,  0.000, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,
               -0.009, -0.014,  0.001,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001,  0.000,  0.000, -0.000, -0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
               -0.009, -0.014,  0.000,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001, -0.000,  0.000, -0.000,  0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.001,  0.001,  0.000,  0.000,  0.000,  0.000,
               0.000 , 0.001 ,-0.000 ,-0.000 , 0.001 ,-0.000 , 0.000 ,-0.000 , 0.000 ,-0.000 ,-0.000 , 0.001 , 0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000,
               -0.000, -0.001,  0.000,  0.001, -0.001, -0.000, -0.001,  0.001,  0.000,  0.001,  0.001,  0.000,  1.708,  0.048,  0.784,  0.062,  0.042,  0.053,  0.077,  0.001, -0.061,  0.046, -0.019, -0.029,  0.000,  0.000,  0.000,  0.000,
               0.000 , 0.001 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 ,-0.000 , 0.048 , 5.001 ,-1.631 ,-0.036 , 0.144 , 0.040 , 0.036 , 0.016 ,-0.051 ,-0.067 ,-0.024 ,-0.005 , 0.000 , 0.000 , 0.000 , 0.000,
               -0.000, -0.001,  0.000,  0.000, -0.001, -0.000, -0.001,  0.000,  0.000,  0.000,  0.000, -0.000,  0.784, -1.631,  1.242,  0.057, -0.037,  0.018,  0.034, -0.017, -0.015,  0.058, -0.021, -0.029,  0.000,  0.000,  0.000,  0.000,
               0.000 , 0.000 , 0.000 , 0.001 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 , 0.062 ,-0.036 , 0.057 , 6.228 ,-0.014 , 0.932 , 0.059 , 0.053 ,-0.069 , 0.148 , 0.015 ,-0.031 , 0.000 , 0.000 , 0.000 , 0.000,
               -0.000,  0.000, -0.000, -0.000,  0.001,  0.000, -0.000,  0.000,  0.000, -0.000,  0.000,  0.000,  0.042,  0.144, -0.037, -0.014,  3.011,  0.986,  0.076,  0.030, -0.052, -0.027,  0.057,  0.051,  0.000,  0.000,  0.000,  0.000,
               -0.001, -0.001, -0.000,  0.001, -0.001,  0.000, -0.001,  0.001, -0.000,  0.001,  0.001,  0.000,  0.053,  0.040,  0.018,  0.932,  0.986,  0.885,  0.090,  0.044, -0.055,  0.057,  0.051, -0.003,  0.000,  0.000,  0.000,  0.000,
               -0.002, -0.003,  0.000,  0.002, -0.003, -0.000, -0.001,  0.002,  0.000,  0.002,  0.002, -0.000,  0.077,  0.036,  0.034,  0.059,  0.076,  0.090,  6.230,  0.139,  0.763,  0.013, -0.019, -0.024,  0.000,  0.000,  0.000,  0.000,
               0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.001 , 0.016 ,-0.017 , 0.053 , 0.030 , 0.044 , 0.139 , 3.130 ,-1.128 ,-0.010 , 0.131 , 0.018 , 0.000 , 0.000 , 0.000 , 0.000,
               -0.000, -0.001, -0.000,  0.000, -0.001, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,  0.000, -0.061, -0.051, -0.015, -0.069, -0.052, -0.055,  0.763, -1.128,  0.866, -0.022, -0.053,  0.007,  0.000,  0.000,  0.000,  0.000,
               -0.003, -0.004, -0.000,  0.003, -0.004, -0.000, -0.003,  0.003,  0.000,  0.003,  0.003,  0.000,  0.046, -0.067,  0.058,  0.148, -0.027,  0.057,  0.013, -0.010, -0.022,  2.437, -0.102,  0.938,  0.000,  0.000,  0.000,  0.000,
               -0.000, -0.000,  0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000,  0.001,  0.000, -0.019, -0.024, -0.021,  0.015,  0.057,  0.051, -0.019,  0.131, -0.053, -0.102,  4.944,  1.724,  0.000,  0.000,  0.000,  0.000,
               -0.001, -0.001,  0.000,  0.001, -0.001,  0.000, -0.001,  0.001, -0.000,  0.001,  0.001,  0.000, -0.029, -0.005, -0.029, -0.031,  0.051, -0.003, -0.024,  0.018,  0.007,  0.938,  1.724,  1.569,  0.000,  0.000,  0.000,  0.000,
               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000 , 0.000 , 0.000,
               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000 , 0.000,
               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000,
               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0;

    // 过程噪声协方差矩阵组件（3x3）
    _Cu <<   268.573,  -43.819, -147.211,
            -43.819 ,  92.949 ,  58.082,
            -147.211,   58.082,  302.120;

    // 完整过程噪声协方差 Q（18x18）
    _QInit = _Qdig.asDiagonal();                // 对角矩阵初始化
    _QInit +=  _B * _Cu * _B.transpose();       // 加入控制输入的影响

    // 协方差监测器初始化    
    _RCheck  = new AvgCov(28, _estName + " R"); // 观测噪声监测
    _uCheck  = new AvgCov(3,  _estName + " u"); // 控制输入监测

    // 低通滤波器初始化（截止频率3Hz）
    _vxFilter = new LPFilter(_dt, 3.0);  // X轴速度滤波
    _vyFilter = new LPFilter(_dt, 3.0);  // Y轴速度滤波
    _vzFilter = new LPFilter(_dt, 3.0);   // Z轴速度滤波

}

void Estimator::run(){
    // 初始化足端高度和运动学参数
    _feetH.setZero();
    _feetPosGlobalKine = _robModel->getFeet2BPositions(*_lowState, FrameType::GLOBAL);
    _feetVelGlobalKine = _robModel->getFeet2BVelocities(*_lowState, FrameType::GLOBAL);

    // 重置噪声协方差矩阵
    _Q = _QInit;
    _R = _RInit;

    // 遍历四条腿调整协方差参数
    for(int i(0); i < 4; ++i){
        if((*_contact)(i) == 0){
            // 悬空腿：增大过程噪声和观测噪声
            _Q.block(6+3*i, 6+3*i, 3, 3) = _largeVariance * I3;
            _R.block(12+3*i, 12+3*i, 3, 3) = _largeVariance * I3;
            _R(24+i, 24+i) = _largeVariance;
        }
        else{
            // 支撑腿：根据相位调整噪声参数
            _trust = windowFunc((*_phase)(i), 0.2);// 计算相位信任度
            _Q.block(6+3*i, 6+3*i, 3, 3) = (1 + (1-_trust)*_largeVariance) * _QInit.block(6+3*i, 6+3*i, 3, 3);
            _R.block(12+3*i, 12+3*i, 3, 3) = (1 + (1-_trust)*_largeVariance) * _RInit.block(12+3*i, 12+3*i, 3, 3);
            _R(24+i, 24+i) = (1 + (1-_trust)*_largeVariance) * _RInit(24+i, 24+i);
        }
        // 更新足端相对机体坐标        
        _feetPos2Body.segment(3*i, 3) = _feetPosGlobalKine.col(i);
        _feetVel2Body.segment(3*i, 3) = _feetVelGlobalKine.col(i);
    }

    // 状态预测阶段
    _rotMatB2G = _lowState->getRotMat(); //// 获取机体到全局的旋转矩阵
    _u = _rotMatB2G * _lowState->getAcc() + _g;// 转换加速度到全局坐标系
    _xhat = _A * _xhat + _B * _u;   // 状态预测方程
    _yhat = _C * _xhat; // 观测预测
    _y << _feetPos2Body, _feetVel2Body, _feetH; // 构建观测向量

    // 卡尔曼滤波更新阶段   
    _Ppriori = _A * _P * _A.transpose() + _Q;// 先验协方差
    _S =  _R + _C * _Ppriori * _C.transpose();// 新增信息协方差
    _Slu = _S.lu();// LU分解用于矩阵求逆

    // 计算卡尔曼增益和相关参数    
    _Sy = _Slu.solve(_y - _yhat);// 观测残差
    _Sc = _Slu.solve(_C);// C矩阵变换
    _SR = _Slu.solve(_R);// R矩阵变换
    _STC = (_S.transpose()).lu().solve(_C);
    _IKC = I18 - _Ppriori*_C.transpose()*_Sc;// 计算逆矩阵

    // 状态更新和协方差更新    
    _xhat += _Ppriori * _C.transpose() * _Sy;// 状态修正
    _P =  _IKC * _Ppriori * _IKC.transpose()// Joseph形式协方差更新
        + _Ppriori * _C.transpose() * _SR * _STC * _Ppriori.transpose();

    // 速度滤波处理
    _vxFilter->addValue(_xhat(3));  // X轴速度低通滤波
    _vyFilter->addValue(_xhat(4));  // Y轴速度低通滤波
    _vzFilter->addValue(_xhat(5));  // Z轴速度低通滤波
}

/**
 * 获取机器人全局坐标系下的位置估计值
 * @return 三维位置向量 [x, y, z]^T (m)
 * 
 * 状态向量说明：
 * _xhat = [位置(3), 速度(3), 足端位置(12)]^T
 * 位置分量存储在状态向量的0-2号元素
 */
Vec3 Estimator::getPosition(){
    return _xhat.segment(0, 3);
}

/**
 * 获取机器人全局坐标系下的速度估计值
 * @return 三维速度向量 [vx, vy, vz]^T (m/s)
 * 
 * 状态向量说明：
 * _xhat = [位置(3), 速度(3), 足端位置(12)]^T
 * 速度分量存储在状态向量的3-5号元素
 */
Vec3 Estimator::getVelocity(){
    return _xhat.segment(3, 3);
}


/**
 * 获取指定腿足端在全局坐标系下的位置
 * @param i 腿的索引（0-3对应左前、右前、左后、右后）
 * @return 三维位置向量 [x, y, z]^T (m)
 * 
 * 计算步骤：
 * 1. 获取足端在机体坐标系下的位置
 * 2. 通过机体旋转矩阵转换到全局坐标系
 * 3. 叠加机体基座全局位置
 * 
 * 坐标系说明：
 * - BODY坐标系：以机器人躯干为中心的坐标系
 * - 全局坐标系：世界固定坐标系
 */
Vec3 Estimator::getFootPos(int i){
     // 足端全局坐标 = 机体全局位置 + 旋转矩阵 * 足端机体相对坐标
    return getPosition() + _lowState->getRotMat() * _robModel->getFootPosition_XM(*_lowState_xm, i, FrameType::BODY);
}

Vec3 Estimator::getBuoyancyCenterPos(int i){
     // 足端全局坐标 = 机体全局位置 + 旋转矩阵 * 足端机体相对坐标
    return getPosition() + _lowState->getRotMat() * _robModel->getBuoyancyCenterPosition(*_lowState_xm, i, FrameType::BODY);
}

Vec3 Estimator::getMassCenterPos(int i){
     // 足端全局坐标 = 机体全局位置 + 旋转矩阵 * 足端机体相对坐标
    return getPosition() + _lowState->getRotMat() * _robModel->getMassCenterPosition(*_lowState_xm, i, FrameType::BODY);
}


/**
 * 获取所有足端在全局坐标系中的位置
 * @return 3x4矩阵，每列对应一个足端的[x,y,z]坐标（米）
 * 
 * 实现原理：
 * 1. 遍历四条腿（0-3索引）
 * 2. 对每条腿调用getFootPos获取其在全局坐标系中的3D坐标
 * 3. 将四个足端坐标按列组合成矩阵返回
 * 
 * 应用场景：
 * - 步态规划时获取足端当前位置
 * - 触地检测时分析足端高度
 */
Vec34 Estimator::getFeetPos(){
    Vec34 feetPos;
    for(int i(0); i < 4; ++i){
        feetPos.col(i) = getFootPos(i);
    }
    return feetPos;
}

Vec34 Estimator::getBuoyancyCenterPos(){
    Vec34 feetPos;
    for(int i(0); i < 4; ++i){
        feetPos.col(i) = getBuoyancyCenterPos(i);
    }
    return feetPos;
}

Vec34 Estimator::getMassCenterPos(){
    Vec34 feetPos;
    for(int i(0); i < 4; ++i){
        feetPos.col(i) = getMassCenterPos(i);
    }
    return feetPos;
}

/**
 * 获取所有足端在全局坐标系中的合成速度
 * @return 3x4矩阵，每列对应一个足端的[vx,vy,vz]速度（米/秒）
 * 
 * 实现原理：
 * 1. 通过机器人模型获取足端本体坐标系下的速度
 * 2. 转换到全局坐标系（通过FrameType::GLOBAL参数）
 * 3. 叠加机体本身的全局运动速度
 * 
 * 速度合成公式：
 * 足端全局速度 = 足端本体相对速度 + 机体全局速度
 * 
 * 典型应用：
 * - 动力学计算时考虑足端惯性力
 * - 滑移检测时分析足端运动状态
 */
Vec34 Estimator::getFeetVel(){
    Vec34 feetVel = _robModel->getFeet2BVelocities_XM(*_lowState_xm, FrameType::GLOBAL);
    for(int i(0); i < 4; ++i){
        feetVel.col(i) += getVelocity();// 叠加机体全局速度分量
    }
    return feetVel;
}

Vec34 Estimator::getBuoyancyCenterVel(){
    Vec34 feetVel = _robModel->getBuoyancyCenter2BVelocities(*_lowState_xm, FrameType::GLOBAL);
    for(int i(0); i < 4; ++i){
        feetVel.col(i) += getVelocity();// 叠加机体全局速度分量
    }
    return feetVel;
}

Vec34 Estimator::getMassCenterVel(){
    Vec34 feetVel = _robModel->getMassCenter2BVelocities(*_lowState_xm, FrameType::GLOBAL);
    for(int i(0); i < 4; ++i){
        feetVel.col(i) += getVelocity();// 叠加机体全局速度分量
    }
    return feetVel;
}

/**
 * 获取各足端在全局坐标系下相对于机体基座的位置
 * @return 3x4矩阵，每列代表一个足端的位置向量 [x, y, z]^T (m)
 * 
 * 计算方法：
 * 1. 通过getFootPos()获取足端全局坐标
 * 2. 减去机体基座全局坐标得到相对位置
 * 
 * 应用场景：
 * - 足端轨迹规划时计算相对机体坐标
 * - 逆运动学解算时获取足端目标位置
 */
Vec34 Estimator::getPosFeet2BGlobal(){
    Vec34 feet2BPos;
    for(int i(0); i < 4; ++i){
        feet2BPos.col(i) = getFootPos(i) - getPosition(); // 相对位置 = 绝对位置 - 基座位置
    }
    return feet2BPos;
}

Vec34 Estimator::getPosFeet2BGlobalBuoyancyCenter(){
    Vec34 feet2BPos;
    for(int i(0); i < 4; ++i){
        feet2BPos.col(i) = getBuoyancyCenterPos(i) - getPosition(); // 相对位置 = 绝对位置 - 基座位置
    }
    return feet2BPos;
}

Vec34 Estimator::getPosFeet2BGlobalMassCenter(){
    Vec34 feet2BPos;
    for(int i(0); i < 4; ++i){
        feet2BPos.col(i) = getMassCenterPos(i) - getPosition(); // 相对位置 = 绝对位置 - 基座位置
    }
    return feet2BPos;
}